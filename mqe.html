<!DOCTYPE html>
<html lang="en">

<head>
    <link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap/dist/css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.css" />
    <link type="text/css" rel="stylesheet" href="CSS_Test/CSS/RichMedia_Proj2_CSS0-1.css">
    <script>
        ///
        // Main structure of map functionality borrowed from Maps HW
        // Edited by Elliot Privateer
        // https://github.com/tonethar/IGME-330-Master/blob/master/notes/_files/Maps-1.pdf
        let map;
        let infoWindow;
        function initMap(loc, zoom) {
            let mapOptions = {
                center: loc,//{ lat: 37.0902, lng: -95.7129 },
                zoom: zoom,
                mapTypeId: google.maps.MapTypeId.ROADMAP
            };
            map = new google.maps.Map(document.getElementById('map'), mapOptions);


            // for future reference
            // let position = {lat:43.082634, lng:-77.68004};
            // let marker = new google.maps.Marker ({position:position, map: map});
            // marker.setTitle("Crossroads");
        }



        function InfoWindow(position, msg) {
            if (infoWindow) infoWindow.close();

            infoWindow = new google.maps.InfoWindow({
                map: map,
                position: position,
                content: "<b>" + msg + "</b>"
            });
        }
        ///

    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDjncHpQdRfjHbDiAyXF8Q-n8UNZ1VHg0w&libraries=places"
        type="text/javascript"></script>
    <script src="//unpkg.com/@babel/polyfill@latest/dist/polyfill.min.js" type="text/javascript"></script>
    <script src="//unpkg.com/vue@latest/dist/vue.min.js" type="text/javascript"></script>
    <script src="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.js" type="text/javascript"></script>

    <title>MapQuakeFind</title>
</head>

<body>
    <div id="mqe-root">
        <h1>Map, Quake, Find</h1>
        <div id="search">
            <div id="bar">
                <select v-model="type">
                    <option v-for="option in valid_types" v-bind:value="option.value">{{option.pretty_name}}</option>
                </select>
                <label><input type="text" v-model="searchLat">Lat</label>
                <label><input type="text" v-model="searchLng">Lng</label>
                <button @click="doSearch">Search</button>
            </div>
            <section>
                <div id="radios">
                    Radius:
                    <label class="radio"><strong>1</strong>
                        <input type="radio" v-model="rad" checked="checked" name="radio" value="1">
                        <span class="check"></span>
                    </label>
                    <label class="radio"><strong>1.5</strong>
                        <input type="radio" v-model="rad" name="radio" value="1.5">
                        <span class="check"></span>
                    </label>
                    <label class="radio"><strong>2</strong>
                        <input type="radio" v-model="rad" name="radio" value="2">
                        <span class="check"></span>
                    </label>
                </div>
                <div id="radios2">
                    Amount:
                    <label class="radio"><strong>2</strong>
                        <input type="radio" v-model="amount" value="2" checked="checked" name="radio2">
                        <span class="check"></span>
                    </label>
                    <label class="radio"><strong>4</strong>
                        <input type="radio" v-model="amount" value="4" name="radio2">
                        <span class="check"></span>
                    </label>
                    <label class="radio"><strong>MAX</strong>
                        <input type="radio" v-model="amount" value="-1" name="radio2">
                        <span class="check"></span>
                    </label>
                </div>
                <div id="range">

                    <div class="slidecontainer">Zoom Slider: <strong>-</strong>
                        <input type="range" min="1" max="100" value="50" class="slider" id="myRange">
                        <strong>+</strong></div>

                </div>


            </section>
            <div id="map"></div>
        </div>
        <div id="results">
            <div id="gm-attrib"></div>
            <div id="loading" v-show="loading">Loading...</div>
            <search-result v-for="result in results" v-bind:result="result"></search-result>
            <div v-if="errorMsg">{{ errorMsg }}</div>
        </div>
    </div>
    <script src="JS/map.js"></script>

    <script>
        function d2r(degrees) {
            return degrees / 180 * Math.PI;
        }
        function geo_distance(start, end) { // haversine
            // taken from https://www.movable-type.co.uk/scripts/latlong.html
            // then mildly optimized by Nic Hartley
            let R = 3956; // miles
            let φ1 = d2r(start.lat);
            let φ2 = d2r(end.lat);
            let shΔφ = Math.sin(d2r(end.lat - start.lat) / 2);
            let shΔλ = Math.sin(d2r(end.lng - start.lng) / 2);

            let a = shΔφ * shΔφ +
                Math.cos(φ1) * Math.cos(φ2) * shΔλ * shΔλ;
            let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            let res = R * c;
            return res;
        }

        class Result {
            static _getEarthquakes() {
                if (Result.earthquakes) {
                    return Promise.resolve(Result.earthquakes);
                } else {
                    return fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson')
                        .then(r => r.json())
                        .then(res => res.features.map(f => {
                            return {
                                mag: f.properties.mag,
                                location: f.properties.place,
                                lat: f.geometry.coordinates[0],
                                lng: f.geometry.coordinates[1],
                                id: f.properties.id,
                            };
                        }))
                        .then(eqs => Result.earthquakes = eqs);
                }
            }

            static search(term, location, max, radius, amount) {
                let mapsPromise = new Promise((ok, err) => {
                    Result.PLACES_SVC.nearbySearch({
                        type: term,
                        location: location,
                        radius: radius * 150 // meters
                    }, (res, status) => {
                        if (status == google.maps.places.PlacesServiceStatus.OK) {
                            console.log("res", res);
                            ///
                            //console.log(location);
                            // Create result array based on limitations from inputs
                            this.maxObjects = res.length;
                            let localObj = [];
                            if (amount == -1)
                                amount = this.maxObjects;
                            if (res.length <= amount)
                                amount = res.length;
                            for (let x = 0; x < amount; x++) {

                                localObj[x] = res[x];
                            }

                            res = localObj;
                            console.log(res);
                            //console.log(res[0].opening_hours.open_now);
                            // Reinitialize map and add new markers based on new elements
                            // Edited by Elliot Privateer
                            initMap(SetMap(res, map, amount), 13, amount);
                            CreateMarkers(res, map, amount);
                            ///
                            //console.log(this.maxObjects);
                            ok(res);
                        } else {
                            err({ code: status, data: res });
                        }
                    })
                });
                return Promise.all([
                    Result._getEarthquakes(),
                    mapsPromise,
                ]).then(p => p[1].map(r => new Result(r, p[0])));
            }

            constructor(raw_result, eqs) {
                this.location = {
                    lat: raw_result.geometry.location.lat(),
                    lng: raw_result.geometry.location.lng(),
                };
                this.location_pretty = `${Math.abs(this.location.lat).toFixed(4)} ${this.location.lat < 0 ? 'E' : 'W'}, ${Math.abs(this.location.lng).toFixed(4)} ${this.location.lng < 0 ? 'N' : 'S'}`
                this.plus_code = raw_result.plus_code.global_code;
                this.icon = raw_result.icon;
                this.name = raw_result.name;
                this.rating = raw_result.rating;
                this.vicinity = raw_result.vicinity;
                this.user_rating = raw_result.user_ratings_total;
                this.earthquakes = eqs.map(e => {
                    e.distance = geo_distance(e, this.location);
                    return e;
                }).filter(e => e.distance < 900 /* miles */).sort((l, r) => l.distance - r.distance);
            }
        }
        Result.PLACES_SVC = new google.maps.places.PlacesService(document.querySelector("#gm-attrib"));

        Vue.component('search-result', {
            props: {
                result: Object,
                required: true,
            },
            template: '<div class="search-result col-sm-12">' +
                '<h3>{{ result.name }}</h3>' +
                '<img v-bind:src="result.icon" />' +
                '<p>Rating: {{result.rating}}</p>' +
                '<p>Total User Rating: {{result.user_rating}}</p>' +
                '<p id="address">Address: {{result.vicinity}}</p>' +
                '<p>{{ result.location_pretty }} ({{ result.plus_code }})</p>' +
                '<ul>' +
                '<li v-for="e in result.earthquakes" :key="e.id">' +
                'Magnitude {{ e.mag }}, location: {{ e.location }} ({{ e.distance.toFixed(2) }} miles away)' +
                '</li>' +
                '</ul>' +
                '</div>',
        });

        ///
        // Creates a markers based on how many results are returned
        // from the search
        // Edited by Elliot Privateer
        function CreateMarkers(positions, map, amount) {
            //console.log(positions[0].name);
            // if(amount == -1)
            //     amount = positions.length;
            // if(positions.length <= amount)
            //     amount = positions.length;

            for (let x = 0; x < amount; x++) {
                // let position = {lat:43.082634, lng:-77.68004};
                // let marker = new google.maps.Marker ({position:position, map: map});
                // marker.setTitle("Crossroads");

                let position = { lat: positions[x].geometry.location.lat(), lng: positions[x].geometry.location.lng() };
                let marker = new google.maps.Marker({ position: position, map: map });
                marker.setTitle(positions[x].name);
            }
        }

        function SetMap(positions, map, amount) {
            let tempLat = 0;
            let tempLng = 0;
            // if(amount == -1)
            //     amount = positions.length;
            // if(positions.length <= amount)
            //     amount = positions.length;

            for (let x = 0; x < amount; x++) {
                tempLat += positions[x].geometry.location.lat();
                tempLng += positions[x].geometry.location.lng();
            }
            tempLat /= positions.length;
            tempLng /= positions.length;

            return { lat: tempLat, lng: tempLng };
        }
        ///

        let app = new Vue({
            el: '#mqe-root',
            data: {
                loading: false,
                results: [],
                type: "restaurant",
                searchLat: 34.0522,
                searchLng: -118.2437,
                map: map,
                amount: 2,
                rad: 1,
                maxObjects: 0,
                valid_types: [
                    // has to be hardcoded, but at least it's stable
                    "accounting", "airport", "amusement_park", "aquarium", "art_gallery", "atm", "bakery", "bank", "bar", "beauty_salon", "bicycle_store", "book_store", "bowling_alley", "bus_station", "cafe", "campground", "car_dealer", "car_rental", "car_repair", "car_wash", "casino", "cemetery", "church", "city_hall", "clothing_store", "convenience_store", "courthouse", "dentist", "department_store", "doctor", "electrician", "electronics_store", "embassy", "fire_station", "florist", "funeral_home", "furniture_store", "gas_station", "gym", "hair_care", "hardware_store", "hindu_temple", "home_goods_store", "hospital", "insurance_agency", "jewelry_store", "laundry", "lawyer", "library", "liquor_store", "local_government_office", "locksmith", "lodging", "meal_delivery", "meal_takeaway", "mosque", "movie_rental", "movie_theater", "moving_company", "museum", "night_club", "painter", "park", "parking", "pet_store", "pharmacy", "physiotherapist", "plumber", "police", "post_office", "real_estate_agency", "restaurant", "roofing_contractor", "rv_park", "school", "shoe_store", "shopping_mall", "spa", "stadium", "storage", "store", "subway_station", "supermarket", "synagogue", "taxi_stand", "train_station", "transit_station", "travel_agency", "veterinary_care", "zoo"
                ].map(v => {return{ value: v, pretty_name: v.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ") };}),
                errorMsg: "",
            },
            methods: {
                doSearch() {
                    this.loading = true;
                    // Result.search(this.type, { lat: 34.0522, lng: -118.2437 }, this.maxObjects)
                    //     .then(r => this.results = r).then(_ => this.loading = false);//.then(initMap());
                    Result.search(this.type, { lat: parseFloat(this.searchLat), lng: parseFloat(this.searchLng) }, this.maxObjects, this.rad, this.amount)
                        .then(r => this.results = r).then(_ => this.loading = false);//.then(initMap());

                }
            }
        });

        ///
        // default initialization
        initMap({ lat: 37.0902, lng: -95.7129 }, 3);
        ///
    </script>
    <!-- <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCVRuIR2xgRM8xP8Djo-q86fP_ITSQoyKw&callback=initMap"
        async defer></script> -->
</body>

</html>