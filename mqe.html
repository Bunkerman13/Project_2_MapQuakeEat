<!DOCTYPE html>
<html lang="en">

<head>
    <link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap/dist/css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.css" />
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDjncHpQdRfjHbDiAyXF8Q-n8UNZ1VHg0w&libraries=places"
        type="text/javascript"></script>
    <script src="//unpkg.com/@babel/polyfill@latest/dist/polyfill.min.js" type="text/javascript"></script>
    <script src="//unpkg.com/vue@latest/dist/vue.min.js" type="text/javascript"></script>
    <script src="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.js" type="text/javascript"></script>

    <style>
        .search-result {
            border: 1px solid black;
        }

    </style>

    <title>MapQuakeEat</title>
</head>

<body>
    <div id="mqe-root">
        <div id="search">
            <button @click="doSearch">Search</button>
        </div>
        <div id="results">
            <div id="gm-attrib"></div>
            <div id="loading" v-show="loading"></div>
            <search-result v-for="result in results" v-bind:result="result"></search-result>
        </div>
    </div>
    <script>
        function d2r(degrees) {
            return degrees / 180 * Math.PI;
        }
        function geo_distance(start, end) { // haversine
            // taken from https://www.movable-type.co.uk/scripts/latlong.html
            // then mildly optimized by Nic Hartley
            let R = 3956; // miles
            let φ1 = d2r(start.lat);
            let φ2 = d2r(end.lat);
            let shΔφ = Math.sin(d2r(end.lat - start.lat) / 2);
            let shΔλ = Math.sin(d2r(end.lng - start.lng) / 2);

            let a = shΔφ * shΔφ +
                Math.cos(φ1) * Math.cos(φ2) *
                shΔλ * shΔλ;
            let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            let res = R * c;
            return res;
        }

        class Result {
            static _getEarthquakes() {
                if (Result.earthquakes) {
                    return Promise.resolve(Result.earthquakes);
                } else {
                    return fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson')
                        .then(r => r.json())
                        .then(res => res.features.map(f => {
                            return {
                                mag: f.properties.mag,
                                location: f.properties.place,
                                lat: f.geometry.coordinates[0],
                                lng: f.geometry.coordinates[1],
                            };
                        }))
                        .then(eqs => Result.earthquakes = eqs);
                }
            }

            static search(term, location) {
                let mapsPromise = new Promise((ok, err) => {
                    Result.PLACES_SVC.findPlaceFromQuery({
                        query: term,
                        locationBias: { radius: 25000, center: location },
                        fields: ['name', 'geometry', 'icon']
                    }, (res, status) => {
                        if (status == google.maps.places.PlacesServiceStatus.OK) {
                            ok(res);
                        } else {
                            err({ code: status, data: res });
                        }
                    })
                });
                return Promise.all([
                    Result._getEarthquakes(),
                    mapsPromise,
                ]).then(p => p[1].map(r => new Result(r, p[0])));
            }

            constructor(raw_result, eqs) {
                this.location = {
                    lat: raw_result.geometry.location.lat(),
                    lng: raw_result.geometry.location.lng(),
                };
                this.icon = raw_result.icon;
                this.name = raw_result.name;
                this.earthquakes = eqs.map(e => {
                    e.distance = geo_distance(e, this.location);
                    return e;
                }).filter(e => e.distance < 2500).sort((l, r) => l.distance - r.distance);
            }
        }
        Result.PLACES_SVC = new google.maps.places.PlacesService(document.querySelector("#gm-attrib"));

        Vue.component('search-result', {
            props: ['result'],
            template: '<div class="search-result">' +
                '<h2>{{ result.name }}</h2>' +
                '<img v-bind:src="result.icon" />' +
                '<p>{{ result.description }}</p>' +
                '<ul>' +
                '<li v-for="e in result.earthquakes">' +
                'Magnitude {{ e.mag }}, location: {{ e.location }} ({{ e.distance.toFixed(2) }} miles away)' +
                '</li>' +
                '</ul>' +
                '</div>',

        });

        let app = new Vue({
            el: '#mqe-root',
            data: {
                loading: false,
                results: [],
            },
            methods: {
                doSearch() {
                    Result.search('restaurant', { lat: 43.0830354, lng: -77.6804358 })
                        .then(r => this.results = r);
                }
            }
        });
    </script>
</body>

</html>
